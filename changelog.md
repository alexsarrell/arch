### 01/12/2024
Добавил buildSrc, core и generator модули, настроил сборку плагинов и gradle, подключил репозитории

### Задачи 01/01/2025
1. Убрать необходимость вручную выбирать тип file source и тип файлов. Логично просто загружать все файлы поддерживаемых типов - In progress
2. Убрать ошибки при отсутствии декларации "doNotTrackState"
3. Наследование и автоматическое определение родительских классов в указанном контексте. Тут сложнее. Какие есть варианты: - In progress
   * Вручную указывать модули, на которые у данного модуля есть депенденси. Как вариант, генерить кор классы в analytics:core и тянуть из него контекст
   * Мы же пишем спецификации для ивентов непосредственно в модуле проекта. Что это нам даёт? А даёт кое-что крутое. Мне, в принципе, А: не нужно изобретать велосипед - в модуле аналитики я могу реализовать набор задачек для генерации ивентов в каждом из модулей. Это позволяет генерить ивенты А в одном модуле, ивенты B в другом. Из этого также следует, что лоадер, который тянет ВСЕ файлы из specDir возможно немного странная затея. Хотя, имеющая право на жизнь. Можно сделать дополнительные параметры конструктора для генерации только переданных files, можно через конкатенацию с относительным путём.
4. Рефакторинг ModelAccessor, он нуждается в переосмыслении - TODO

Что нужно обдумать: 
1. Как правильно импортировать классы-родители. Я бы добавил дополнительный параметр parentPackage нуллабельный. По дефолту он тот же, что и дочерний, и все импортируемые parent классы просто импортируются с префиксом parentPackage.
2. Продолжая тему проблем с наследованием. Варианта 2: Мы либо загружаем в контекст ВСЕ файлы из basePath, но генерируем только классы, указанные в specsLimit, либо грузим только указанные в specsLimit классы, перелопачиваем логику ссылок и делаем ссылки на парентов как в open-api.

Плюсы первого варианта: в теории меньше переделывать
Минусы первого варианта: не очень с точки зрения архитектуры

Плюсы первого варианта: быстрее, гибче, логичнее с точки зрения архитектуры
Минусы: Больше переделывать

Останавливаюсь на втором варианте, накидаем техдиз.
Ссылки на классы из соседних файлов оставляем схоже с open-api.

Пример:
Файл analytics-core.yml
```yaml
schemas:
  AnalyticsEvent:
    description: Base analytics interface
    type: abstract
    properties:
      name:
        type: String
        description: Name of the event
        version: 1.0.0
        required: true
      accountId:
        type: String
        format: uuid
        description: ID of the event
        version: 1.0.0
        required: true
      metadata:
        type: String # TODO добавить нормальную поддержку кастомных типов без необходимости объяв
        description: Metadata of the event
        default: emptyMap<String, Any>
        version: 1.0.0
        required: true
    version: 2.0.0
```

Файл analytics-example.yml
```yaml
schemas:
  HelloWorldEvent:
    type: data
    parent: "./analytics-core.yml#/schemas/AnalyticsEvent"
```

Как будет происходить загрузка таких темплейтов?
При помощи кастомного KSerializer - ParentSerializer.
У Schema класса в parent указывается не String, а @Serializable аннотированное ParentRef свойство.
Вопрос:
Как извлекать Schema по такой ссылке? Какая логика будет внутри Serializer?
Ответ:
В сериалайзере загружаем файл по относительной ссылке и сохраняем её в ParentRef. ParentRef - класс обёртка, используемый для валидации ссылок.

Флоу загрузки спеки:
1. Выгружаем все файлы подходящего расширения из rootDir. Сейчас результатом LoadPipe является мапа String: String, где ключ - имя файла, значение - .readText(). Для большей гибкости и нужд разработки предлагаю вгружать в контекст Set<File>.
2. ParsePipe. Сейчас метод loadSpecs принимает на вход мапу, нужно принимать Set<File>. На этапе парсинга производятся следующие операции: 
   1. Выгрузка схем
   2. Резолв ссылок
   3. Фильтр того, что фильтруем, а что не фильтруем
3. В генератор улетают схемы, которые нужно сгенерить

Мы молодцы огромные - уже генерим по спеке и умеем в наследование.
Из следующих дел:
пройтись по тудушкам, удалить неиспользуемые классы, подумать над оптимизацией загрузчика родительских классов (там точно можно что-то кэшировать), протестировать подтягивание спек из жарников, отрефачить моменты с передачей контекстов, добавить поддержку parentPackage, возможно подумать в сторону переделки modelAccessor, пройтись по регексам и вынести их куда-то, отвалидировать если нужно, поддержка метадата аннотаций (i.e. @EventName и остальное + X-кастом), упростить себе жизнь автоматической компиляцией плагинов. Импорт маппинги и база базовых импортов для поддержки дат и всего такого. Поддержка переопределения темплейтов. Выпилить, там где можно, мапки и LoadResult'ы.